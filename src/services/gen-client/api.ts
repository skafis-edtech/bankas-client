/* tslint:disable */
/* eslint-disable */
/**
 * Skafis užduočių bankas API
 * This is bankas.skafis.lt API. https://api.bankas.skafis.lt
 *
 * The version of the OpenAPI document: 3.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CategoryDisplayDto
 */
export interface CategoryDisplayDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryDisplayDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDisplayDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDisplayDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CategoryDisplayDto
     */
    'problemCount': number;
}
/**
 * 
 * @export
 * @interface CategoryPostDto
 */
export interface CategoryPostDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface IdDto
 */
export interface IdDto {
    /**
     * 
     * @type {string}
     * @memberof IdDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface IdSkfDto
 */
export interface IdSkfDto {
    /**
     * 
     * @type {string}
     * @memberof IdSkfDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IdSkfDto
     */
    'skfCode': string;
}
/**
 * 
 * @export
 * @interface ImageSrcDto
 */
export interface ImageSrcDto {
    /**
     * 
     * @type {string}
     * @memberof ImageSrcDto
     */
    'src': string;
}
/**
 * 
 * @export
 * @interface ProblemDisplayViewDto
 */
export interface ProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProblemDisplayViewDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProblemDisplayViewDto
     */
    'categories': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemVisibility': ProblemDisplayViewDtoProblemVisibilityEnum;
}

export const ProblemDisplayViewDtoProblemVisibilityEnum = {
    Visible: 'VISIBLE',
    Hidden: 'HIDDEN',
    NotExisting: 'NOT_EXISTING'
} as const;

export type ProblemDisplayViewDtoProblemVisibilityEnum = typeof ProblemDisplayViewDtoProblemVisibilityEnum[keyof typeof ProblemDisplayViewDtoProblemVisibilityEnum];

/**
 * 
 * @export
 * @interface ProblemSubmitDto
 */
export interface ProblemSubmitDto {
    /**
     * 
     * @type {number}
     * @memberof ProblemSubmitDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'answerText': string;
}
/**
 * 
 * @export
 * @interface ProblemTextsDto
 */
export interface ProblemTextsDto {
    /**
     * 
     * @type {number}
     * @memberof ProblemTextsDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemTextsDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemTextsDto
     */
    'answerText': string;
}
/**
 * 
 * @export
 * @interface ReviewMsgDto
 */
export interface ReviewMsgDto {
    /**
     * 
     * @type {string}
     * @memberof ReviewMsgDto
     */
    'reviewMessage': string;
}
/**
 * 
 * @export
 * @interface SourceDisplayDto
 */
export interface SourceDisplayDto {
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'visibility': SourceDisplayDtoVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'reviewStatus': SourceDisplayDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'reviewHistory': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'authorUsername': string;
    /**
     * 
     * @type {number}
     * @memberof SourceDisplayDto
     */
    'problemCount': number;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'lastModifiedOn': string;
}

export const SourceDisplayDtoVisibilityEnum = {
    Public: 'PUBLIC',
    Private: 'PRIVATE'
} as const;

export type SourceDisplayDtoVisibilityEnum = typeof SourceDisplayDtoVisibilityEnum[keyof typeof SourceDisplayDtoVisibilityEnum];
export const SourceDisplayDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourceDisplayDtoReviewStatusEnum = typeof SourceDisplayDtoReviewStatusEnum[keyof typeof SourceDisplayDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourceSubmitDto
 */
export interface SourceSubmitDto {
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'visibility': SourceSubmitDtoVisibilityEnum;
}

export const SourceSubmitDtoVisibilityEnum = {
    Public: 'PUBLIC',
    Private: 'PRIVATE'
} as const;

export type SourceSubmitDtoVisibilityEnum = typeof SourceSubmitDtoVisibilityEnum[keyof typeof SourceSubmitDtoVisibilityEnum];

/**
 * 
 * @export
 * @interface StatsDto
 */
export interface StatsDto {
    /**
     * 
     * @type {number}
     * @memberof StatsDto
     */
    'problemCount': number;
}
/**
 * 
 * @export
 * @interface UserDataDto
 */
export interface UserDataDto {
    /**
     * 
     * @type {string}
     * @memberof UserDataDto
     */
    'bio': string;
    /**
     * 
     * @type {number}
     * @memberof UserDataDto
     */
    'balance': number;
}
/**
 * 
 * @export
 * @interface UserPublicDataDto
 */
export interface UserPublicDataDto {
    /**
     * 
     * @type {string}
     * @memberof UserPublicDataDto
     */
    'bio': string;
}

/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrivateCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('createPrivateCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/private`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('createPublicCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrivateCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePrivateCategory', 'id', id)
            const localVarPath = `/category/private/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePublicCategory', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrivateCategory: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePrivateCategory', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updatePrivateCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/private/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicCategory: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePublicCategory', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updatePublicCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrivateCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrivateCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.createPrivateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.createPublicCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrivateCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrivateCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.deletePrivateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.deletePublicCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrivateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrivateCategory(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.updatePrivateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicCategory(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.updatePublicCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrivateCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.createPrivateCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.createPublicCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrivateCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePrivateCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePublicCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrivateCategory(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.updatePrivateCategory(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicCategory(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.updatePublicCategory(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public createPrivateCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).createPrivateCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public createPublicCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).createPublicCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deletePrivateCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).deletePrivateCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deletePublicCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).deletePublicCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updatePrivateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).updatePrivateCategory(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updatePublicCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).updatePublicCategory(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryViewControllerApi - axios parameter creator
 * @export
 */
export const CategoryViewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryView/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryById', 'categoryId', categoryId)
            const localVarPath = `/categoryView/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsByCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getProblemsByCategory', 'categoryId', categoryId)
            const localVarPath = `/categoryView/problemsByCategory/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsUnsorted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryView/problemsUnsorted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryViewControllerApi - functional programming interface
 * @export
 */
export const CategoryViewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryViewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryViewControllerApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryViewControllerApi.getCategoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsByCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryViewControllerApi.getProblemsByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsUnsorted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsUnsorted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryViewControllerApi.getProblemsUnsorted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryViewControllerApi - factory interface
 * @export
 */
export const CategoryViewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryViewControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<CategoryDisplayDto>> {
            return localVarFp.getCategories(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(categoryId: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsByCategory(categoryId: string, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsByCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsUnsorted(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsUnsorted(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryViewControllerApi - object-oriented interface
 * @export
 * @class CategoryViewControllerApi
 * @extends {BaseAPI}
 */
export class CategoryViewControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryViewControllerApi
     */
    public getCategories(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return CategoryViewControllerApiFp(this.configuration).getCategories(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryViewControllerApi
     */
    public getCategoryById(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoryViewControllerApiFp(this.configuration).getCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryViewControllerApi
     */
    public getProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoryViewControllerApiFp(this.configuration).getProblemsByCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryViewControllerApi
     */
    public getProblemsUnsorted(options?: RawAxiosRequestConfig) {
        return CategoryViewControllerApiFp(this.configuration).getProblemsUnsorted(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentControllerApi - axios parameter creator
 * @export
 */
export const ContentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswerImage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAnswerImage', 'id', id)
            const localVarPath = `/content/problem/answerImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblem', 'id', id)
            const localVarPath = `/content/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblemImage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblemImage', 'id', id)
            const localVarPath = `/content/problem/problemImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/content/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/mySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem: async (sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('submitProblem', 'sourceId', sourceId)
            // verify required parameter 'problem' is not null or undefined
            assertParamExists('submitProblem', 'problem', problem)
            const localVarPath = `/content/submit/problem/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problem !== undefined) { 
                localVarFormParams.append('problem', new Blob([JSON.stringify(problem)], { type: "application/json", }));
            }
    
            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData: async (sourceSubmitDto: SourceSubmitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceSubmitDto' is not null or undefined
            assertParamExists('submitSourceData', 'sourceSubmitDto', sourceSubmitDto)
            const localVarPath = `/content/submit/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSubmitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblemTexts: async (id: string, problemTextsDto: ProblemTextsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProblemTexts', 'id', id)
            // verify required parameter 'problemTextsDto' is not null or undefined
            assertParamExists('updateProblemTexts', 'problemTextsDto', problemTextsDto)
            const localVarPath = `/content/problem/texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemTextsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, sourceSubmitDto: SourceSubmitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'sourceSubmitDto' is not null or undefined
            assertParamExists('updateSource', 'sourceSubmitDto', sourceSubmitDto)
            const localVarPath = `/content/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSubmitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAnswerImage: async (id: string, answerImageFile: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadAnswerImage', 'id', id)
            // verify required parameter 'answerImageFile' is not null or undefined
            assertParamExists('uploadAnswerImage', 'answerImageFile', answerImageFile)
            const localVarPath = `/content/problem/answerImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProblemImage: async (id: string, problemImageFile: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadProblemImage', 'id', id)
            // verify required parameter 'problemImageFile' is not null or undefined
            assertParamExists('uploadProblemImage', 'problemImageFile', problemImageFile)
            const localVarPath = `/content/problem/problemImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentControllerApi - functional programming interface
 * @export
 */
export const ContentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnswerImage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnswerImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.deleteAnswerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.deleteProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblemImage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblemImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.deleteProblemImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.getMySources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdSkfDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProblem(sourceId, problem, problemImageFile, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.submitProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSourceData(sourceSubmitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.submitSourceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProblemTexts(id, problemTextsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.updateProblemTexts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, sourceSubmitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.updateSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAnswerImage(id: string, answerImageFile: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageSrcDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAnswerImage(id, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.uploadAnswerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProblemImage(id: string, problemImageFile: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageSrcDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProblemImage(id, problemImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentControllerApi.uploadProblemImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentControllerApi - factory interface
 * @export
 */
export const ContentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentControllerApiFp(configuration)
    return {
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswerImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAnswerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblemImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblemImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getMySources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: any): AxiosPromise<IdSkfDto> {
            return localVarFp.submitProblem(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: any): AxiosPromise<IdDto> {
            return localVarFp.submitSourceData(sourceSubmitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProblemTexts(id, problemTextsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, sourceSubmitDto: SourceSubmitDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.updateSource(id, sourceSubmitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAnswerImage(id: string, answerImageFile: File, options?: any): AxiosPromise<ImageSrcDto> {
            return localVarFp.uploadAnswerImage(id, answerImageFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProblemImage(id: string, problemImageFile: File, options?: any): AxiosPromise<ImageSrcDto> {
            return localVarFp.uploadProblemImage(id, problemImageFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentControllerApi - object-oriented interface
 * @export
 * @class ContentControllerApi
 * @extends {BaseAPI}
 */
export class ContentControllerApi extends BaseAPI {
    /**
     * Delete answer image by ID.
     * @summary USER but owning. Delete answer image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public deleteAnswerImage(id: string, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).deleteAnswerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete problem by ID.
     * @summary USER but owning. Delete problem
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public deleteProblem(id: string, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).deleteProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete problem image by ID.
     * @summary USER but owning. Delete problem image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public deleteProblemImage(id: string, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).deleteProblemImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete source with all problems by ID.
     * @summary USER but owning. Delete source with all problems
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public deleteSource(id: string, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).deleteSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all sources submitted by the current user.
     * @summary USER. Get my sources
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public getMySources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).getMySources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
     * @summary USER. Submit problem data with images
     * @param {string} sourceId 
     * @param {ProblemSubmitDto} problem 
     * @param {File} [problemImageFile] 
     * @param {File} [answerImageFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).submitProblem(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit source data for approval. Returns the ID of the created source.
     * @summary USER. Submit source data
     * @param {SourceSubmitDto} sourceSubmitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).submitSourceData(sourceSubmitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update problem texts by ID.
     * @summary USER but owning. Update problem texts
     * @param {string} id 
     * @param {ProblemTextsDto} problemTextsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).updateProblemTexts(id, problemTextsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update source data by ID.
     * @summary USER but owning. Update source data
     * @param {string} id 
     * @param {SourceSubmitDto} sourceSubmitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public updateSource(id: string, sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).updateSource(id, sourceSubmitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload answer image by ID.
     * @summary USER but owning. Upload answer image
     * @param {string} id 
     * @param {File} answerImageFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public uploadAnswerImage(id: string, answerImageFile: File, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).uploadAnswerImage(id, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload problem image by ID.
     * @summary USER but owning. Upload problem image
     * @param {string} id 
     * @param {File} problemImageFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentControllerApi
     */
    public uploadProblemImage(id: string, problemImageFile: File, options?: RawAxiosRequestConfig) {
        return ContentControllerApiFp(this.configuration).uploadProblemImage(id, problemImageFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscControllerApi - axios parameter creator
 * @export
 */
export const MiscControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This endpoint is called to trigger prod API every 10 minutes and keep it alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerService: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/misc/triggerService`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscControllerApi - functional programming interface
 * @export
 */
export const MiscControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary This endpoint is called to trigger prod API every 10 minutes and keep it alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerService(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerService(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscControllerApi.triggerService']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscControllerApi - factory interface
 * @export
 */
export const MiscControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary This endpoint is called to trigger prod API every 10 minutes and keep it alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerService(options?: any): AxiosPromise<string> {
            return localVarFp.triggerService(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscControllerApi - object-oriented interface
 * @export
 * @class MiscControllerApi
 * @extends {BaseAPI}
 */
export class MiscControllerApi extends BaseAPI {
    /**
     * 
     * @summary This endpoint is called to trigger prod API every 10 minutes and keep it alive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscControllerApi
     */
    public triggerService(options?: RawAxiosRequestConfig) {
        return MiscControllerApiFp(this.configuration).triggerService(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewControllerApi - axios parameter creator
 * @export
 */
export const ReviewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: async (sourceId: string, reviewMsgDto: ReviewMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('approve', 'sourceId', sourceId)
            // verify required parameter 'reviewMsgDto' is not null or undefined
            assertParamExists('approve', 'reviewMsgDto', reviewMsgDto)
            const localVarPath = `/review/approve/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pending sources submitted for approval.
         * @summary ADMIN. Get pending sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingSources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/review/pendingSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject: async (sourceId: string, reviewMsgDto: ReviewMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('reject', 'sourceId', sourceId)
            // verify required parameter 'reviewMsgDto' is not null or undefined
            assertParamExists('reject', 'reviewMsgDto', reviewMsgDto)
            const localVarPath = `/review/reject/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewControllerApi - functional programming interface
 * @export
 */
export const ReviewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approve(sourceId, reviewMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.approve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pending sources submitted for approval.
         * @summary ADMIN. Get pending sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingSources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.getPendingSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reject(sourceId, reviewMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.reject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewControllerApi - factory interface
 * @export
 */
export const ReviewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewControllerApiFp(configuration)
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.approve(sourceId, reviewMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pending sources submitted for approval.
         * @summary ADMIN. Get pending sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingSources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getPendingSources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.reject(sourceId, reviewMsgDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewControllerApi - object-oriented interface
 * @export
 * @class ReviewControllerApi
 * @extends {BaseAPI}
 */
export class ReviewControllerApi extends BaseAPI {
    /**
     * Approve source with problems by source ID.
     * @summary ADMIN. Approve source with problems
     * @param {string} sourceId 
     * @param {ReviewMsgDto} reviewMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).approve(sourceId, reviewMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pending sources submitted for approval.
     * @summary ADMIN. Get pending sources
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public getPendingSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).getPendingSources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject source with problems by source ID.
     * @summary ADMIN. Reject source with problems
     * @param {string} sourceId 
     * @param {ReviewMsgDto} reviewMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).reject(sourceId, reviewMsgDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourceViewControllerApi - axios parameter creator
 * @export
 */
export const SourceViewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedSources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sourceView/approvedSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource: async (sourceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProblemsBySource', 'sourceId', sourceId)
            const localVarPath = `/sourceView/problemsBySource/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else.
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceById', 'sourceId', sourceId)
            const localVarPath = `/sourceView/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {GetSourcesByAuthorSortByEnum} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesByAuthor: async (authorUsername: string, page?: number, size?: number, search?: string, sortBy?: GetSourcesByAuthorSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorUsername' is not null or undefined
            assertParamExists('getSourcesByAuthor', 'authorUsername', authorUsername)
            const localVarPath = `/sourceView/sourcesByAuthor/{authorUsername}`
                .replace(`{${"authorUsername"}}`, encodeURIComponent(String(authorUsername)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceViewControllerApi - functional programming interface
 * @export
 */
export const SourceViewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceViewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovedSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovedSources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceViewControllerApi.getApprovedSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsBySource(sourceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsBySource(sourceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceViewControllerApi.getProblemsBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else.
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceById(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceById(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceViewControllerApi.getSourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {GetSourcesByAuthorSortByEnum} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, sortBy?: GetSourcesByAuthorSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourcesByAuthor(authorUsername, page, size, search, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceViewControllerApi.getSourcesByAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourceViewControllerApi - factory interface
 * @export
 */
export const SourceViewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceViewControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedSources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getApprovedSources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource(sourceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsBySource(sourceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else.
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById(sourceId: string, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.getSourceById(sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {GetSourcesByAuthorSortByEnum} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, sortBy?: GetSourcesByAuthorSortByEnum, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getSourcesByAuthor(authorUsername, page, size, search, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceViewControllerApi - object-oriented interface
 * @export
 * @class SourceViewControllerApi
 * @extends {BaseAPI}
 */
export class SourceViewControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceViewControllerApi
     */
    public getApprovedSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return SourceViewControllerApiFp(this.configuration).getApprovedSources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems submitted for the source.
     * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
     * @param {string} sourceId 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceViewControllerApi
     */
    public getProblemsBySource(sourceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SourceViewControllerApiFp(this.configuration).getProblemsBySource(sourceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source by ID. Returns source entity.
     * @summary PUBLIC if approved, USER if owned, ADMIN else.
     * @param {string} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceViewControllerApi
     */
    public getSourceById(sourceId: string, options?: RawAxiosRequestConfig) {
        return SourceViewControllerApiFp(this.configuration).getSourceById(sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} authorUsername 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {GetSourcesByAuthorSortByEnum} [sortBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceViewControllerApi
     */
    public getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, sortBy?: GetSourcesByAuthorSortByEnum, options?: RawAxiosRequestConfig) {
        return SourceViewControllerApiFp(this.configuration).getSourcesByAuthor(authorUsername, page, size, search, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSourcesByAuthorSortByEnum = {
    NameAsc: 'NAME_ASC',
    NameDesc: 'NAME_DESC',
    Newest: 'NEWEST',
    Oldest: 'OLDEST',
    MostProblems: 'MOST_PROBLEMS',
    LeastProblems: 'LEAST_PROBLEMS'
} as const;
export type GetSourcesByAuthorSortByEnum = typeof GetSourcesByAuthorSortByEnum[keyof typeof GetSourcesByAuthorSortByEnum];


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary USER
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getData: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getData', 'username', username)
            const localVarPath = `/user/data/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicData: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPublicData', 'username', username)
            const localVarPath = `/user/publicData/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {UserPublicDataDto} userPublicDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio: async (userPublicDataDto: UserPublicDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPublicDataDto' is not null or undefined
            assertParamExists('updateBio', 'userPublicDataDto', userPublicDataDto)
            const localVarPath = `/user/bio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPublicDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary USER
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getData(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getData(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicData(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublicDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicData(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getPublicData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {UserPublicDataDto} userPublicDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBio(userPublicDataDto: UserPublicDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBio(userPublicDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary USER
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getData(username: string, options?: any): AxiosPromise<UserDataDto> {
            return localVarFp.getData(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicData(username: string, options?: any): AxiosPromise<UserPublicDataDto> {
            return localVarFp.getPublicData(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {UserPublicDataDto} userPublicDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio(userPublicDataDto: UserPublicDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateBio(userPublicDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary USER
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getData(username: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getData(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getPublicData(username: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getPublicData(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {UserPublicDataDto} userPublicDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateBio(userPublicDataDto: UserPublicDataDto, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateBio(userPublicDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ViewControllerApi - axios parameter creator
 * @export
 */
export const ViewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemBySkfCode: async (skfCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skfCode' is not null or undefined
            assertParamExists('getProblemBySkfCode', 'skfCode', skfCode)
            const localVarPath = `/view/problem/{skfCode}`
                .replace(`{${"skfCode"}}`, encodeURIComponent(String(skfCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/view/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewControllerApi - functional programming interface
 * @export
 */
export const ViewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemBySkfCode(skfCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDisplayViewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemBySkfCode(skfCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ViewControllerApi.getProblemBySkfCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ViewControllerApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ViewControllerApi - factory interface
 * @export
 */
export const ViewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemBySkfCode(skfCode: string, options?: any): AxiosPromise<ProblemDisplayViewDto> {
            return localVarFp.getProblemBySkfCode(skfCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<StatsDto> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewControllerApi - object-oriented interface
 * @export
 * @class ViewControllerApi
 * @extends {BaseAPI}
 */
export class ViewControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} skfCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewControllerApi
     */
    public getProblemBySkfCode(skfCode: string, options?: RawAxiosRequestConfig) {
        return ViewControllerApiFp(this.configuration).getProblemBySkfCode(skfCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewControllerApi
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return ViewControllerApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }
}



